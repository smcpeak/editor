

3/28/01 03:31

got the font stuff working after looking in many places.

to find out the name of the current font:

  myFontStruct = XQueryFont(display, XGContextFromGC(gc));
  XGetFontProperty(fs, XA_FONT, &nameAtom);
  char *name = XGetAtomName(display, nameAtom);
  printf("font name: %s\n", name);
  
to set it to use a new font:

  myFontId = XLoadFont(display, myFontName);
  XSetFont(display, gc, myFontId);

so current list of todos:

  - get the cursor update working right
    - draw the cursor by first snapshotting the image underneath
      where I want to draw (must calculate a bounding box), then
      draw whatever I want, then replace the image when I want
      to move it or flash it or whatever
  - make the cursor bigger, proper height by font, etc.
  - ability to load and save files
  - different colors than black/white
  - more keybindings ....
  - systematic way of naming keys (the emacs way is close)
  - scrolling
  - a keyboard-activated menu
  - some way of prompting for interactive input -- a dialog box
    - need to make a new window, which prevents interaction
      with the underlying window
    - that dialog needs some buttons
    - and a text widget, ideally with configurable key bindings
    - and some dialog-wide keyboard navigation
  - ability to select text
  - copy+paste       
  - redraw button, and/or proper redrawing generally
    - still need window coords

fixed newline problem

some malloc mischief?  hard to reproduce...

end 3/28/01 04:26

---------------------------------------------
start 3/29/01 03:59

let's try to make some simple dialog boxes with Motif

so far I've been unable to make it drop into a modal
loop, which is really required for proper composability..

end 3/29/01 05:32

--------------------------------------
start 3/31/01 22:39

more attempts to make a file-load dialog box

found that I can make a modal event model by building
my own event loop.  however:
  - that does nothing for the app input, which I need to
    separately disable
  - I must not create the dialog inside the menu's callback
    function because it has the mouse input captured (!)
    until the callback returns
  - not obvious when to end event loop, because not all window
    destruction paths go through my callbacks
    
this seems to argue for constructing my own callback structure..

solved the when-to-end problem by making the loop guard:

  XtIsManaged(dialog) || XtAppPending(app)
  
this makes sure we quit as soon as the dialog disappears, and
the event queue is quiescent

actually, since the sample code just says it wants to make sure
the widget is "destroyed", I think the XtIsManaged should be
sufficient..

------------------------
start 4/09/01 11:26

more dialog stuff ...

-------------------
start 7/18/02 10:15

resuming work after a long time..

renaming Cursor to Position.. done

end 7/18/02 13:45

---------------
start 7/18/02 17:36

what I need from a widget set / toolkit:
  - menus
  - scroll bars that I can put at the sides of my content windows
  - file chooser dialog
  - ability to make simple custom dialogs; needed controls:
    - static label
    - text input (with optional dropdown history)
    - list box with at least single selection
    - checkbox, radio button
    - push buttons

-------------------
start 2/08/03 02:17

looking at this again.  I've found my widget set: Qt.  so the
short-term project now is to embed what I have inside a Qt
framework instead of an X11 framework

also made a tentative decision to use Guile for my scripting
engine when the time comes

---------------
start 2/09/03 00:07

continuing to get what I had to work under Qt

ok, everything that was working now does again

fixed some issues with deletion

next task: embed the editor widget into a more fully-functional
GUI environment (load named file, save named file, scrolling) so
I can experiment with more realistic files and file sizes

end 2/09/03 02:44

---------------
start 2/09/03 14:52

todo:
  - load file
  - save file
  - scrolling
  
did load and save, but I've got a bug in my Buffer implementation
that's causing me to trash memory.. will switch on the debug heap
to find it next time

end 2/09/03 17:15

--------------
start 2/10/03 17:58

fixed the bug last night.. now can I save and load?  yes

let's now get the text-rendering procedure working a bit better,
and in the process implement scrolling

major todos:
  - support for multiple simultanous files
  - syntax highlighting!
  - undo
  - incremental search
  * redesign buffer representation, interface (think about undo...)
  * selections, copy, paste

bug: backspace causes segfault!

new design for buffer interface:
  - manipulate the spine:
    - insert a new line at n
    - delete the blank line at n (must already be blank!)
  - manipulate a single line:
    - insert a given string at a given line/col
    - delete a given # of chars at a given line/col
  - manipulate the cursor (purely for undo/redo)
    - move to absolute line/col
    - move to relative line/col

this interface seems to work well with:
  - buffer representation itself
  - undo/redo log
  - incremental lexer and syntax highlighter

new buffer repr:
  - spine of char*, terminated by '\n', and with no add'l gap
  - gap on the spine
  - *one* most-recently-edited line with gap repr (and NULL spine ptr, maybe)
  - NULL spine ptr for blank lines
  
end 2/11/03 00:03

-----------------
start 2/11/03 02:15

looked at debugging the backspace-segfault problem, it's not
so easy..

decided to go ahead and rewrite Buffer since I want to anyway
and I'm tired of debugging the bad design

wrote a gap-array module, and a unit test, but it doesn't pass yet
fixed it

end 2/11/03 04:56

------------------
start 2/11/03 15:42

now to rewrite Buffer to use the new GapArray and a better
interface in general

came up with solution for mapping between line offsets and char
offsets: simultanous relative contiguous interval map
  - binary tree indexed by line/char offset
  - relative: every time you go right, subtract the node's indices
  - incremental: update an interval, then update the indices on the
    path to that interval everywhere you went left in the tree
  - possible enhancement: make it balanced?

finished coding Buffer, seems to work

end 2/11/03 18:34

--------------
start 2/11/03 20:18

will modify surrounding editor to use new Buffer interface.. first
up is BufferState, which needs to acquire some of the convenience
functions that Buffer had

ok, I've now hooked everything up adequately that I'm editing this
very line in the new editor!  that's pretty cool.  all the functions
appear to work correctly.

end 2/11/03 22:37

---------------
start 2/11/03 23:59

will work on selections

have the basic rendering engine working

TODO: there's a bug in the way PageUp behaves at/beyond the bottom
of the file.. can't quite figure out what's going on..

selection rendering appears to work!

end 2/12/03 03:19

-------------------------------
start 2/14/03 22:47

first: fix pageup bug.. fixed by cutting an event loop.. not
perfect, but is probably good anway, and it solves my problem

need to implement copy, cut, paste.. done!

looking at syntax highlighting...

plan:
  - styledb: module to maintain global list of font/fg/bg triples
  - hilite: interface to highlighter (very simple)
  - c_hilite: module to highlight C/C++, configurable map from
    lexical concepts to styles in the styledb
   
end 2/15/03 04:30

----------------
start 2/16/03 01:28

will implement a few of the highlighting things..

closer to understanding how to hijack a flex lexer
for my purposes..

end 2/16/03 04:14

------------------------
start 2/16/03 10:55

I'll experiment with the interface by trying to implement
a highlighter for comments and strings only

end 2/16/03 12:17

------------------
start 2/22/03 23:09

more.. getting comment.lex to work, then we'll see about using
it for highlighting

there's a problem with the representation of the 'changed'
region, in that a 'changed' line near the end that never gets
highlighted will keep most of the table polluted for a long
time.. I really need a proper relative interval map, and I need
that for later as well, so perhaps next time I can implement
that

I need to test the implementation I have, though I'm kind of
out of steam...

end 2/23/03 03:19

------------------------------
start 2/25/03 09:30

have a solution to the flaw above: in addition to the 'changed'
region I'll have a water mark below which no highlighting has
been done.  of the real set of changed lines, the changed set I
maintain will be the topmost contiguous region, the remainder
below the water mark.  for the usual case of opening a file and
scrolling through it, this will highlight only as far as the
user has seen, which might be a good thing (perhaps want preference
to demand-highlight the whole thing on startup)

done with waterline implementation





