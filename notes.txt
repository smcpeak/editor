
TODOs:
  - during event recording, for a key press whose path has empty
    elements, check if can represent as FocusKeyEvent
  - way to replace all in file
  - smbase has some problems in test-overflow.cc with NDEBUG due to
    use of 'assert'
  - in tests, explicitly indicate which file to open
  - Ctrl+O dialog: always scroll to the top
  - deal with F4 keybinding collision between SAR and Close document
    - I think just remove F4 binding.  Alt+F, C is not bad.
  - Ctrl+I cannot open "../smbase/test.h:58:13" if cursor is at start
    - then, when it is not, we get ".." in the document path name
  - put "<running>" into the window title
  - if I select text, Ctrl+I should open that w/o filename heuristics
  - working on automated GUI tests
  - draw an indicator when the cursor is offscreen
  - split panes, esp. a vertical split instead of multiple windows
  - allow Tab character; issue is rendering support
  - run command to generate entire file; git annotate!
    - enhancements
      - prompt on closure of document with running process
      - soft end of buffer jumping
      - when switch to output buffer, need to jump to end
      - process output documents should not be editable!
        - but Save As should transition them to normal editable files
      - open-files-dialog: button to close all with finished processes
      - annoying completion behavior of Qt combo boxes; want more like
        shell with readline (except less buggy!)
      - after reusing a document to run the same command, would like
        the cursor to stay where it was, unless it was at the end
          - interact with the "soft" end tracking
    - shell
      - put a panel on the bottom for input line that will be passed
        to the child process
    - git diff
    - git show
    - grep
    - compilation mode
    - parallel compilation mode that keeps the various output streams
      separate somehow
  - rename all references to "open-files dialog" to "documents"?

  - very annoyed by the scrollbar thumb being too light
    - spent a while digging through QStyle docs and (mostly) code,
      could not figure out how to do this; bailing for now
  - refactor: split SARPanel into pixel/key layer and stateful UI layer
  - document list: instead of N/P, let user type a substring of a doc
    name?
    - maybe after Ctrl+S?
  - prompt before killing an Alt+A that takes too long
  - highlighting for mismatch parens, braces, etc.
  - highlighting for "git diff" output
  - command line arguments to set window position(s)?
  - undo history is never truncated... I should add something to check
    for excessive memory usage over time
  - for grep and compile, something to (1) recognize lines that have
    file/line info, and (2) ability to see each in a different pane
    or window or something

  - handling of files with CRLF line endings
    - highlighting of backslash followed by CR is busted
      - not recognized as continuation; see a .moc.cc file
    - ability to make line endings uniform
    - ability to insert lines with CRLF
  - parenthesis balancing, and Alt-[/] to find matching delimiter
  - mode to show line numbers in left margin
  - multiple copy+paste strings

  - better vertical scrollbar
    - graphically depict entire file's contents?

  - ctrl+i: open file at cursor
    - try with fewer directory components so I can open a file from
      a name like "a/Makefile" in "git diff" output
  - search and replace
    - allow Ctrl+R from the main editor window too
    - unclear when Ctrl+R will replace versus jump
    - issues when cursor is sitting on a match but it isn't highlighted
    - allow F2? Ctrl+O? Ctrl+I?
    - explicit case sensitivity option
    - whole word?
    - regex...
      - needs redesign of how the matching algorithm works
    - history!
    - better feedback on search: number of hits, at first/last/only/none

  - handle cygwin paths on the command line (requires Alt+A infra)

  - test plan
  - support for encodings other than Latin-1
  - save/restore set of open buffers
  - periodic autosave; do that when receiving SIGTERM/QUIT/INT also
  - if I press Delete while the cursor is at the left edge of a blank
    line, make it delete that line even if there is whitespace on it
  - remove unnecessary triple buffering from render code

Projects:
  - idea: "edit" a git diff?





----------------------------
3/28/01 03:31

got the font stuff working after looking in many places.

to find out the name of the current font:

  myFontStruct = XQueryFont(display, XGContextFromGC(gc));
  XGetFontProperty(fs, XA_FONT, &nameAtom);
  char *name = XGetAtomName(display, nameAtom);
  printf("font name: %s\n", name);

to set it to use a new font:

  myFontId = XLoadFont(display, myFontName);
  XSetFont(display, gc, myFontId);

so current list of todos:

  - get the cursor update working right
    - draw the cursor by first snapshotting the image underneath
      where I want to draw (must calculate a bounding box), then
      draw whatever I want, then replace the image when I want
      to move it or flash it or whatever
  - make the cursor bigger, proper height by font, etc.
  - ability to load and save files
  - different colors than black/white
  - more keybindings ....
  - systematic way of naming keys (the emacs way is close)
  - scrolling
  - a keyboard-activated menu
  - some way of prompting for interactive input -- a dialog box
    - need to make a new window, which prevents interaction
      with the underlying window
    - that dialog needs some buttons
    - and a text widget, ideally with configurable key bindings
    - and some dialog-wide keyboard navigation
  - ability to select text
  - copy+paste
  - redraw button, and/or proper redrawing generally
    - still need window coords

fixed newline problem

some malloc mischief?  hard to reproduce...

end 3/28/01 04:26

---------------------------------------------
start 3/29/01 03:59

let's try to make some simple dialog boxes with Motif

so far I've been unable to make it drop into a modal
loop, which is really required for proper composability..

end 3/29/01 05:32

--------------------------------------
start 3/31/01 22:39

more attempts to make a file-load dialog box

found that I can make a modal event model by building
my own event loop.  however:
  - that does nothing for the app input, which I need to
    separately disable
  - I must not create the dialog inside the menu's callback
    function because it has the mouse input captured (!)
    until the callback returns
  - not obvious when to end event loop, because not all window
    destruction paths go through my callbacks

this seems to argue for constructing my own callback structure..

solved the when-to-end problem by making the loop guard:

  XtIsManaged(dialog) || XtAppPending(app)

this makes sure we quit as soon as the dialog disappears, and
the event queue is quiescent

actually, since the sample code just says it wants to make sure
the widget is "destroyed", I think the XtIsManaged should be
sufficient..

------------------------
start 4/09/01 11:26

more dialog stuff ...

-------------------
start 7/18/02 10:15

resuming work after a long time..

renaming Cursor to Position.. done

end 7/18/02 13:45

---------------
start 7/18/02 17:36

what I need from a widget set / toolkit:
  - menus
  - scroll bars that I can put at the sides of my content windows
  - file chooser dialog
  - ability to make simple custom dialogs; needed controls:
    - static label
    - text input (with optional dropdown history)
    - list box with at least single selection
    - checkbox, radio button
    - push buttons

-------------------
start 2/08/03 02:17

looking at this again.  I've found my widget set: Qt.  so the
short-term project now is to embed what I have inside a Qt
framework instead of an X11 framework

also made a tentative decision to use Guile for my scripting
engine when the time comes

---------------
start 2/09/03 00:07

continuing to get what I had to work under Qt

ok, everything that was working now does again

fixed some issues with deletion

next task: embed the editor widget into a more fully-functional
GUI environment (load named file, save named file, scrolling) so
I can experiment with more realistic files and file sizes

end 2/09/03 02:44

---------------
start 2/09/03 14:52

todo:
  - load file
  - save file
  - scrolling

did load and save, but I've got a bug in my Buffer implementation
that's causing me to trash memory.. will switch on the debug heap
to find it next time

end 2/09/03 17:15

--------------
start 2/10/03 17:58

fixed the bug last night.. now can I save and load?  yes

let's now get the text-rendering procedure working a bit better,
and in the process implement scrolling

major todos:
  - support for multiple simultaneous files
  * syntax highlighting!
  - undo
  * incremental search
  * redesign buffer representation, interface (think about undo...)
  * selections, copy, paste

bug: backspace causes segfault!

new design for buffer interface:
  - manipulate the spine:
    - insert a new line at n
    - delete the blank line at n (must already be blank!)
  - manipulate a single line:
    - insert a given string at a given line/col
    - delete a given # of chars at a given line/col
  - manipulate the cursor (purely for undo/redo)
    - move to absolute line/col
    - move to relative line/col

this interface seems to work well with:
  - buffer representation itself
  - undo/redo log
  - incremental lexer and syntax highlighter

new buffer repr:
  - spine of char*, terminated by '\n', and with no add'l gap
  - gap on the spine
  - *one* most-recently-edited line with gap repr (and NULL spine ptr, maybe)
  - NULL spine ptr for blank lines

end 2/11/03 00:03

-----------------
start 2/11/03 02:15

looked at debugging the backspace-segfault problem, it's not
so easy..

decided to go ahead and rewrite Buffer since I want to anyway
and I'm tired of debugging the bad design

wrote a gap-array module, and a unit test, but it doesn't pass yet
fixed it

end 2/11/03 04:56

------------------
start 2/11/03 15:42

now to rewrite Buffer to use the new GapArray and a better
interface in general

came up with solution for mapping between line offsets and char
offsets: simultanous relative contiguous interval map
  - binary tree indexed by line/char offset
  - relative: every time you go right, subtract the node's indices
  - incremental: update an interval, then update the indices on the
    path to that interval everywhere you went left in the tree
  - possible enhancement: make it balanced?

finished coding Buffer, seems to work

end 2/11/03 18:34

--------------
start 2/11/03 20:18

will modify surrounding editor to use new Buffer interface.. first
up is BufferState, which needs to acquire some of the convenience
functions that Buffer had

ok, I've now hooked everything up adequately that I'm editing this
very line in the new editor!  that's pretty cool.  all the functions
appear to work correctly.

end 2/11/03 22:37

---------------
start 2/11/03 23:59

will work on selections

have the basic rendering engine working

TODO: there's a bug in the way PageUp behaves at/beyond the bottom
of the file.. can't quite figure out what's going on..

selection rendering appears to work!

end 2/12/03 03:19

-------------------------------
start 2/14/03 22:47

first: fix pageup bug.. fixed by cutting an event loop.. not
perfect, but is probably good anway, and it solves my problem

need to implement copy, cut, paste.. done!

looking at syntax highlighting...

plan:
  * styledb: module to maintain global list of font/fg/bg triples
  * hilite: interface to highlighter (very simple)
  * c_hilite: module to highlight C/C++, configurable map from
    lexical concepts to styles in the styledb

end 2/15/03 04:30

----------------
start 2/16/03 01:28

will implement a few of the highlighting things..

closer to understanding how to hijack a flex lexer
for my purposes..

end 2/16/03 04:14

------------------------
start 2/16/03 10:55

I'll experiment with the interface by trying to implement
a highlighter for comments and strings only

end 2/16/03 12:17

------------------
start 2/22/03 23:09

more.. getting comment.lex to work, then we'll see about using
it for highlighting

there's a problem with the representation of the 'changed'
region, in that a 'changed' line near the end that never gets
highlighted will keep most of the table polluted for a long
time.. I really need a proper relative interval map, and I need
that for later as well, so perhaps next time I can implement
that

I need to test the implementation I have, though I'm kind of
out of steam...

end 2/23/03 03:19

------------------------------
start 2/25/03 09:30

have a solution to the flaw above: in addition to the 'changed'
region I'll have a water mark below which no highlighting has
been done.  of the real set of changed lines, the changed set I
maintain will be the topmost contiguous region, the remainder
below the water mark.  for the usual case of opening a file and
scrolling through it, this will highlight only as far as the
user has seen, which might be a good thing (perhaps want preference
to demand-highlight the whole thing on startup)

done with waterline implementation

struggling with getting flex to output lexers that can be
linked in each others' presence

end 2/25/03 16:20

--------------------
start 2/26/03 02:01

ok, will hack it for now.. done

got C++ highlighting working pretty well!

end 2/26/03 04:01

----------------
start 2/26/03 05:10

playing with it a bit more

more todo:
  - alt+ins to toggle ins/overwrite
  * auto-indent
  * alt+left/right
  * ctrl+alt+left/right
  - tabs
  - File|Rename, that writes to a new name and deletes the old one
  - bookmarks, with markers on the scrollbar
  - paren-matching indication
  * search+replace
  * Ctrl+L: center window vertically

end 2/26/03 06:54

---------------------
start 2/28/03 04:14

bugs:
  * open editor.cc, go to end of file, open editor.h: now at end
    of that file, should be at start
  - open nonexistent file, shouldn't clear current contents

got basics of i-search working

end 2/28/03 06:18

-------------
start 2/28/03 07:26

i-search ideas:
  * "not found" box that appears near the cursor when match isn't found;
    it says whether ctrl+s would get another match after cycling
  * key bindings in status bar instead of the match string
  * highlight all matches onscreen
  - key to toggle whether all onscreen hits are highlighted
  - require enter or Esc to exit, so I can more flexibly bind add'l keys;
    in particular, allow scrolling to work normally by letting it go
    through
  * incremental replace works just like i-search, but when you press enter
    you're in a mode to enter the replacement text (directly into the
    buffer?), and then another mode for successive replacements
  - could do incremental regexp search/replace by popping up a new window
    for entering the expression, but incrementally show matches like normal
    i-search does; key to go back and forth between regexp and normal
    i-search
  * key to toggle case-sensitivity of the search
  - match across multiple lines?
  - key to toggle whitespace insensitivity (e.g. " " == "\t" == "  ")
  - key to search only in comments, or only outside comments
  - key to show all buffer matches on the scrollbar
  * key to change direction of search (forward vs. backward)

end 2/28/03 11:09

-----------
start 2/28/03 11:33

implemented ctrl+s wraparound

implemented cool hit-text thing!

end 2/28/03 12:06

--------------
start 2/28/03 13:33

implemented Ctrl+A, etc. emacs bindings

next: auto-indent.. done

alt+left/right.. done

thinking about design for search+replace.. current ideas:
  - three modes: search, entering replacement, replacing
  - enter moves forward, esc moves back, among modes
  - replacing, replacement text is in buffer, selected, in place of
    first match (replacing it is implicit once enter pressed, unless esc)
    - printable: add chars
    - backspace: remove char
    - enter: done
    - esc: back
    - up/down: history of replacement texts
  - replacing:
    - left/right: move to next/prev occurrence
    - y: replace
    - n: next occurrence
    - !: replace all, done
    - q: done

end 2/28/03 16:17

-----------------------
start 3/01/03 06:59

will implement replacing.. ok, seems to work

thinking about how to handle multiple buffers.. Window menu approach
doesn't leave a place for other metadata about the buffers.. dialog-only
approach is rather heavy-weight.. emacs' buffer list is clunky and
unintuitive..

one idea is some kind of widget that is related to the status bar
display of the current buffer's file name.. like you click there and
something unrolls to show the buffer info.. but that ends up not being
all that different from a Window menu

tabs take up space and don't provide much information

bug:
  - File|Open, then switch to another app, then back to Open dialog,
    choose new file: editor view doesn't redraw

----------------------------
start 3/27/03 15:09

needed to finish up the multi-file support.  that's now basically
done, but with several todos:
  - need File|Close menu option
  - need the search+replace interface to interact with buffer
    cycling correctly (need to decide just what that is)
  - better naming of buffers?  command-line name is relative, while
    names from the dialog are absolute.. also unique untitled.txt
    variant for each File|New
  - allow many files to be spec'd on command line


design for an undo/history system:

goals:
  - editing sequence should be largely location independent, so
    they still work after changing some prior commands
    - so, the editing *cursor* is part of the abstraction
  - the concrete syntax is both readable (clear meaning) and writable
    (compact notation)
  - every command is reversible, *without* checkpointing.  needed b/c:
    - state must not be hidden, so script can be edited as text
    - checkpointing doesn't scale
  - open problem: handling correspondence mismatch
    - approach 1: automatic repair; but this is likely to do the wrong
      thing most of the time
    - approach 2: stop and demand manual repair (prefer this)
  - do *not* include the selection in the log
    - minimal information to lose
    - contributes nothing to location independence
    - highly non-orthogonal, making reversibility much harder
  - would like language to have non-reversible degenerate forms, to allow
    scripts to be written by hand and essentially become reversible when
    instantiated (like a macro); or, since I want macros to be a more
    powerful language generally, maybe I just want entirely different
    languages for the different purposes...

constructs of language:
  - cursor movement: move(L, C)
    - each L and C can be either a relative offset or an absolute value
    - relative is +n or -n; +0 and -0 are synonyms
    - absolute is n<-m, meaning go to n and we're at m now (for reversing)
  - insertLeft and insertRight: insert text, and leave cursor to left
    or right; "insert" is then an alias for insertRight
  - deleteLeft and deleteRight: delete text; command accepts string argument
    saying what text is deleted; "delete" an alias for deleteLeft so it's
    the natural inverse of insert
  - both insert and delete take add'l argument, saying how many chars of
    whitespace fill are added to end of line/file before inserting/deleting;
    this is always a sequence of newlines followed by a sequence of spaces;
    fill defaults to 0 if not specified (in the concrete syntax)
  - group ["label"] { ... } to group constructs so the interactive undo/redo
    does them all together
  - reverse ["label"] { ... } like "group" but actions are done in reverse


end 3/27/03 16:45


---------------------
start 3/27/03 19:01

plan for history is to start by inserting a layer directly above BufferCore,
called BufferHistory, that exposes exactly the interface above for manipulating
text.  it will also provide read-only access directly to BufferCore.  then
Buffer will be modified to provide the same services it does now, but using
the BufferHistory manipulation mechanism instead of that of BufferCore

difficulty: buffers with multiple views open..

end 3/27/03 20:18


----------------------
start 5/19/03 18:04

want to get the editor working.. need undo facility

as above, architecture is:

         +--------+
         | Buffer |  (exposed)
         +------------------+
         | HistoryBuffer    |
         +------------------+
         | CursorBufferCore |    (BufferCore + line/col)
         +------------------+
         | BufferCore       |
         +------------------+

internal to HistoryBuffer will be a representation of that history
as a GapArray of 'long'.  when LSB is 0, it's a pointer to an object
implementing an interface that can apply itself in forward or reverse
to a CursorBufferCore.  when LSB is 1, it's one of three special cases:
  RelRelCursor:
    signed int dline : 8;     // delta in lines
    signed int dcol  : 8;     // delta in cols
  AbsColumn:
    unsigned int dest : 8;    // col to move to
    unsigned int src  : 8;    // col moving from
    // line does not change
  CharInsDel:
    unsigned int ch   : 17;   // unicode character code
    bool ins          : 1;    // 1=insert, 0=delete
    bool left         : 1;    // 1=left, 0=right
    unsigned int fill : 8;    // fill chars
and I'll use a 3-bit opcode to pick among these and any future codes,
leaving 1 unused bit in CharInsDel, the most bit-hungry record

end 5/19/03 19:30

-------------------
start 5/20/03 01:34

will implement basic object-oriented history sequence..

got part of it.. it's a bit more complicated than I initially
realized, because the system needs unsynchronized operations to
avoid modifying the buffer.. but I now think I know how to
structure the operations to accomplish that

end 5/20/03 03:20

--------------------
start 5/20/03 22:48

trouble of a new sort: I want to be able to re-use the machinery
used to verify that a HistoryElt is consistent, to also fill in
that consistency information in the first place

for fill, it's relatively easy, since I can just compute line/col fill
and use that for both purposes.  however, for deletions (esp. left
deletions), it's not as clear whether one can design an interface to
the computation that is then easy to use for both purposes, or whether
'apply' should get yet more complicated and have an option to 'fix'..
that option might be useful in its own right when the info is found
to be wrong, or perhaps just as easily the redesigned interface could
be used in a third way, for patching inconsistent histories..

hmmm....

end 5/21/03 02:06

----------------
start 5/30/03 14:10

plan: factor out the 'compute' part of the record verification, and
expose that to make it easier to construct records

hmm..

end 5/30/03 17:00

---------------
start 5/31/03 01:27

new plan:
  - first, remove 'fill' from the insert/delete records
  - implement grouping
  - plan on having lots of groups, and a mechanism to recognize
    and special-case empty and singleton groups

essentially, open a group at the beginning of the UI processing
switch(), and close it at the end, so that all UI actions are
exactly undoable in one step; don't optimize particular combinations,
because in fact the one combination I tried to optimize is a rather
rare one, I'm now convinced, having seen and implemented several
other combinations

ok, this all worked pretty well, and I've got Buffer reimplemented
on top of HistoryBuffer.  the test program 'buffer' dies with a
failed assertion, so I'll debug that next time

end 5/31/03 03:59

-------------------------
start 5/31/03 20:49

debugging the assertion failure..

found the problem: inadequate planning of the interaction between
files' on-disk repr., in-memory repr., and the cursor.  I've now
figured that out and know how to fix it, will document in
buffercore.h

ok, got the editor to compile and run again!  still haven't
hooked up or measured the undo/redo, but supposedly it's
back there working...

end 6/01/03 00:30

-------------------------
start 6/01/03 03:01

need to hook up and test the undo/redo facility; also need
measurements of space usage, etc.

fixed a bug in ogap.h, spent quite a while trying to make
a signal handler that would automatically diagnose part
of the cause, eventually leading to a kernel bug with the
sigaltstack() function, from which I retreated

anyway, extremely simple undo/redo is working, need to test
it some more

end 6/01/03 06:21

-----------------------
start 6/06/03 17:02

here's what I have right now:
  records      : 43
  groups       : 1
  memUsage     : 928
  mallocObjects: 88
  reservedSpace: 16
  totalUsage() : 1296

will implement some compression schemes..

did the 32-bit encoding stuff:
  records      : 43
  groups       : 1
  memUsage     : 214
  mallocObjects: 4
  reservedSpace: 16
  totalUsage() : 246

implemented a bunch of stuff related to hooking undo/redo up.

todo to get editor usable:
  - window menu with list of open files
  - ability to close a file (File|Close I guess)
  - autosave, incl. when I get a bad signal
  - multiple frames/windows

end 6/06/03 22:50


plan:
  - pass 1: assign menu ids (positive) and hotkeys
  - pass 2: build menus

---------------------------------
start 9/26/03 00:06

brought over things from the laptop, finally

ctrl-z, ctrl-w should work while in search mode

implemented a few things

end 9/26/03 01:33

-------------------------
start 9/26/03 17:10

looking at performance issues... I cannot measure any significant
time spent inside the editor itself, and 'top' is indicating that
most time is spent in the X server, presumably responding to all
my drawing requests and then blitting

so a key difficulty at this point is I don't have a way to measure
the current performance

in any event, I can try to make some provements.  basic plan is
to install an observer that can track buffer/cursor/sel(?) changes
between frames, and try to build as much of the new frame as
possible out of pieces of the old frame, translated as necessary

state that contributes to a frame:
  - buffer contents
  - view upper-left coordinates
  - cursor location
  - selection state (active, mark location)
  - search highlight string

made a significant improvement simply by avoiding the creation
of a buffer for the entire window

end 08/26/03 22:14

------------------
start 08/27/03 01:54

implementd Alt+G

end 08/27/03 03:47

---------------
start 2008-12-13 00:10

  convert repo to git .. done

  porting to current Qt and smbase .. done

  get keys to work again .. got it

    needed to call setFocusPolicy(QWidget::StrongFocus) in
    the ctor of Editor

  font .. unsuccessful

  need to make a library for fonts:

    - BDF font object
    - BDF renderer to X pixmap with color choice

end 2008-12-13 02:15

-----------------------
start 2008-12-13 11:58

  BDF font system

  http://partners.adobe.com/public/developer/en/font/5005.BDF_Spec.pdf

---------------------
2008-12-15 19:25

  working on qtbdffont module

---------------------
start 2009-02-13 02:31

  qtbdffont

  stopped using editor/smbase, instead using ../smbase

  added exhausitve rendering tests

  fixed some bugs with zero bbox and zero offset

end 2009-02-13 05:51

--------------------------
start 2009-02-16 05:01

  modify editor to use qtbdffont

  but now it is much slower!  :(

  hmmm...

  course of action:
    - quantify the problem, either with editor or qtbdffont
    - confirm hypothesis that masked blits are the problem by
      disabling the mask temporarily
    - investigate Qt source code to confirm it is doing client-side
      bltting, and what the conditions on that are
    - possibly look into a Qt upgrade
    - or an X configuration issue?
    - may have to use pre-rendered opaque glyphs

end 2009-02-16 07:28

--------------
start 2009-06-13 14:25

  test that mask is the problem, use pre-rendered opaque glyphs

    at full screen, currently takes 200 ms to draw a frame

    once the mask is removed, it's 10 ms per frame

    confirmed

  Finished making the opaque rendering changes, but the result
  is weird because only the bounding box is opaque; the rest of
  the character cell (which is itself not a very general concept)
  is left transparnet.  So clients have to erase the background
  in advance anyway, yet cannot do overlap effects like kerning.
  Highly non-ideal, but I don't see any better solution unless
  I can get mask blitting to work fast, and I do not see an
  obvious solution to that.

  attempted to update ered to use this font system; problems:

  * lurs12 has some typographical spacing problems; either need
    to fix them or find another font

  * interline spacing is too large; BDF does not specify it so
    we use the bbox which is quite poor

  * seems to be a bug somewhere making the relation labels show up
    too low and a little to the right (?)

  * drawCentered needs to erase the whole BG rectangle

  * (big one) In general, opaque text drawing causes major
    problems for both the implementation and the UI.  I think I'm
    going to only find more and harder to solve problems with it.
    I think my next attack strategy has to focus on figuring out
    why I cannot do masked blits efficiently.

end 2009-06-13 19:55

-------------------
start 2009-06-14 12:44

  need to see if there is a way to get the mask effect to be
  fast; options:

  - play with bit depths, etc., of the original approach

  - study Qt sources for reasons for slow fallbacks

  - use instead a 32-bit image with alpha; but that could not
    possibly be fast on an 8-bit display, right?

  - do the whole thing using OpenGL instead

  experimenting with performance in 'qtbdffont' program, I can
  draw the test string "drawString(QtBDFFont &)" 1000 times in:

    2781 ms using the mask
      23 ms not using the mask

  study of Qt's bitBlt code (by copying it into my own and then
  hacking it to compile) reveals:

  * The code path it's using is the "fast masked blt" path, so
    there isn't anything majorly wrong with my use.

  * Basic timing shows all the time spent in XCopyArea, although
    that can of course be misleading due to write-back caching.

  * I can improve speed 5x by calling setOptimization(QPixmap::BestOptim),
    since that caches the GC that stores the mask.

  * I can improve by another 5x if I can reduce/eliminate the
    calls to XSetClipOrigin in the bitBlt implementation.  It
    is unfortunate that the clip origin is relative to the
    destination drawable.  Changing it seems to have a major
    impact on the X server's drawing speed.

    - One possible way to do that is to render entire strings
      at once, creating one mask for the entire string.

  decisions:

  * Revert QtBDFFont to expose the transparent drawing interface,
    since that is what clients need.  Obviously, add the
    setOptimization() call to get my 5x.

  * Also expose an optional opaque-rendering interface that
    works by setting the background of the colorpixmap and
    disabling the mask.  Clients willing to make and maintain
    a lot of QtBDFFont objects, and deal with opaque rendering,
    will be able to take advantage of the speed gain.

  * Otherwise, it's up to the client to use its own damage
    tracking and bulk scrolling mechanisms to reduce the number
    of calls into the drawCharacter routine.

end 2009-06-14 15:02

--------------
start 2009-06-14 21:41

  restore the transparent text capabilities of QtBDFFont

  done; current typical results:

    transparent: 1000 iters in 511 ms
    opaque: 1000 iters in 45 ms

end 2009-06-14 23:39

------------------
start 2009-06-16 20:00

  trying to make editor usable for day-to-day editing

  implemented:

    * box cursor like emacs
    * ctrl-G to cancel search
    * what happened to alt-left-arrow?

end 2009-06-16 22:12

----------------------------
2018-07-07 23:30

Notes on how QTableView interrogates QAbstractItemModel:
  - startup
    - rowCount (multiple times)
    - columnCount (multiple times)
    - headerData for each row:
      - 13: size
      - 6: font
      - 0: text
      - 1: decoration
    - headerData for each column:
      - 13, 6, 0, 1
    - data for each cell, row-major, in order:
      - 6: font
      - 7: alignment
      - 9: foreground brush
      - 10: check state
      - 1: decoration
      - 0: text
      - 8: background brush
    - headerData for each row:
      - 6: font
      - 7: alignment
      - 0: text
      - 1: decoration
      - 9: fg
      - 8: bg
    - headerData for each column:
      - 6, 7, 0, 1, 9, 8
  - mouse over a header
    - repeat headerData query for column 1 (x2)
    - because it is changing the bg color as mouse goes over
  - mouse over a cell
    - data 3: tooltip
  - something else?
    - repeat cycle of querying row headers, column headers, cells
  - scroll
    - query affected cells: 6, 7, 9, 10, 1, 0, 8


---------------------------
2018-07-20 16:13

Junk to delete:


  // QCoreApplication methods.
  virtual bool notify(QObject *receiver, QEvent *event) OVERRIDE;

  // QObject methods.
  virtual bool eventFilter(QObject *receiver, QEvent *event) OVERRIDE;


static string objectPath(QObject const *obj)
{
  if (!obj) {
    return "NULL";
  }

  if (!obj->parent()) {
    // Root object.
    return toString(obj->objectName());
  }
  else {
    return stringb(objectPath(obj->parent()) << "." << obj->objectName());
  }
}


static string objectDesc(QObject const *obj)
{
  if (!obj) {
    return "NULL";
  }

  stringBuilder sb;
  sb << "{name=\"" << obj->objectName()
     << "\" path=\"" << objectPath(obj)
     << "\" addr=" << (void*)obj
     << " class=" << obj->metaObject()->className()
     << "}";
  return sb;
}


static int g_eventCounter=0;

bool GlobalState::notify(QObject *receiver, QEvent *event)
{
  int eventNo = g_eventCounter++;

  if (event->type() == QEvent::KeyPress) {
    QKeyEvent const *keyEvent = dynamic_cast<QKeyEvent const *>(event);
    if (keyEvent) {
      TRACE("input2", eventNo << ": "
                      "KeyPress to " << objectDesc(receiver) <<
                      ": ts=" << keyEvent->timestamp() <<
                      " key=" << toString(*keyEvent) <<
                      " acc=" << keyEvent->isAccepted() <<
                      " focus=" << objectDesc(QApplication::focusWidget()));
    }
    else {
      TRACE("input2", eventNo << ": KeyPress has an unknown event class!");
    }

    bool ret = this->QApplication::notify(receiver, event);

    TRACE("input2", eventNo << ": returns " << ret <<
                    ", acc=" << keyEvent->isAccepted());

    return ret;
  }

  if (event->type() == QEvent::Shortcut) {
    QShortcutEvent const *shortcutEvent =
      dynamic_cast<QShortcutEvent const *>(event);
    if (shortcutEvent) {
      TRACE("input2", eventNo << ": "
                      "Shortcut to " << objectDesc(receiver) <<
                      ": ambig=" << shortcutEvent->isAmbiguous() <<
                      " id=" << shortcutEvent->shortcutId() <<
                      " keys=" << shortcutEvent->key().toString() <<
                      " acc=" << shortcutEvent->isAccepted() <<
                      " focus=" << objectDesc(QApplication::focusWidget()));
    }
    else {
      TRACE("input2", eventNo << ": Shortcut has an unknown event class!");
    }

    bool ret = this->QApplication::notify(receiver, event);

    TRACE("input2", eventNo << ": returns " << ret <<
                    ", acc=" << shortcutEvent->isAccepted());

    return ret;
  }

  return this->QApplication::notify(receiver, event);
}


int g_filterCounter = 0;

bool GlobalState::eventFilter(QObject *receiver, QEvent *event)
{
  int eventNo = g_filterCounter++;

  if (event->type() == QEvent::KeyPress) {
    QKeyEvent const *keyEvent = dynamic_cast<QKeyEvent const *>(event);
    if (keyEvent) {
      TRACE("filter", eventNo << ": "
                      "KeyPress to " << objectDesc(receiver) <<
                      ": ts=" << keyEvent->timestamp() <<
                      " key=" << toString(*keyEvent) <<
                      " acc=" << keyEvent->isAccepted() <<
                      " focus=" << objectDesc(QApplication::focusWidget()));
    }
    else {
      TRACE("filter", eventNo << ": KeyPress has an unknown event class!");
    }
  }

  if (event->type() == QEvent::Shortcut) {
    QShortcutEvent const *shortcutEvent =
      dynamic_cast<QShortcutEvent const *>(event);
    if (shortcutEvent) {
      TRACE("filter", eventNo << ": "
                      "Shortcut to " << objectDesc(receiver) <<
                      ": ambig=" << shortcutEvent->isAmbiguous() <<
                      " id=" << shortcutEvent->shortcutId() <<
                      " keys=" << shortcutEvent->key().toString() <<
                      " acc=" << shortcutEvent->isAccepted() <<
                      " focus=" << objectDesc(QApplication::focusWidget()));
    }
    else {
      TRACE("filter", eventNo << ": Shortcut has an unknown event class!");
    }
  }

  return false;
}




EOF
