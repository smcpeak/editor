// vfs-connections.cc
// Code for vfs-connections.h.

#include "vfs-connections.h"           // this module

// editor
#include "vfs-query.h"                 // FileSystemQuery

// smbase
#include "container-utils.h"           // contains
#include "exc.h"                       // GENERIC_CATCH_BEGIN/END
#include "map-utils.h"                 // insertMapUnique, keySet
#include "trace.h"                     // TRACE
#include "vector-utils.h"              // vec_erase
#include "xassert.h"                   // xfailure

// libc++
#include <set>                         // std::set
#include <utility>                     // std::move



// ---------------------------- Connection -----------------------------
VFS_Connections::Connection::Connection(VFS_Connections *connections,
                                        HostName const &hostName)
  : m_connections(connections),
    m_hostName(hostName),
    m_fsQuery(new FileSystemQuery),
    m_currentRequestID(0),
    m_queuedRequests()
{
  // The signals generated by 'm_fsQuery' are sent to 'm_connections'
  // for processing.
  //
  // It might be a good idea to change this to have the Connection
  // object handle the signals directly.
  QObject::connect(m_fsQuery.get(), &FileSystemQuery::signal_connected,
                   m_connections, &VFS_Connections::on_connected);
  QObject::connect(m_fsQuery.get(), &FileSystemQuery::signal_replyAvailable,
                   m_connections, &VFS_Connections::on_replyAvailable);
  QObject::connect(m_fsQuery.get(), &FileSystemQuery::signal_failureAvailable,
                   m_connections, &VFS_Connections::on_failureAvailable);

  m_fsQuery->connect(m_hostName);
}


VFS_Connections::Connection::~Connection()
{
  // See doc/signals-and-dtors.txt.
  QObject::disconnect(m_fsQuery.get(), nullptr, m_connections, nullptr);
}


// Note: Some Connection methods are defined further below, near the
// functions that call them.


// ------------------------- VFS_Connections ---------------------------
VFS_Connections::VFS_Connections()
  : QObject(),
    m_nextRequestID(1),
    m_validHostNames(),
    m_connections(),
    m_availableReplies()
{}


VFS_Connections::~VFS_Connections()
{}


void VFS_Connections::selfCheck() const
{
  xassert(vec_element_set(m_validHostNames) == keySet(m_connections));
}


bool VFS_Connections::isValid(HostName const &hostName) const
{
  return contains(m_connections, hostName);
}


std::vector<HostName> VFS_Connections::getHostNames() const
{
  return m_validHostNames;
}


void VFS_Connections::connect(HostName const &hostName)
{
  TRACE("VFS_Connections", "connect: " << hostName);

  xassert(!isValid(hostName));

  m_validHostNames.push_back(hostName);
  insertMapUniqueMove(m_connections, hostName,
    std::unique_ptr<Connection>(new Connection(this, hostName)));
}


VFS_Connections::Connection const *
  VFS_Connections::connC(HostName const &hostName) const
{
  if (!contains(m_connections, hostName)) {
    xfailure(stringb("Invalid host: " << hostName));
  }

  return m_connections.at(hostName).get();
}


bool VFS_Connections::isConnecting(HostName const &hostName) const
{
  return connC(hostName)->m_fsQuery->isConnecting();
}


bool VFS_Connections::isReady(HostName const &hostName) const
{
  return connC(hostName)->m_fsQuery->isReady();
}


void VFS_Connections::issueRequest(RequestID /*OUT*/ &requestID,
                                   HostName const &hostName,
                                   std::unique_ptr<VFS_Message> req)
{
  requestID = m_nextRequestID++;

  TRACE("VFS_Connections",
    "enqueued: requestID=" << requestID <<
    " host=" << hostName <<
    " type=" << toString(req->messageType()));

  Connection *c = conn(hostName);
  c->m_queuedRequests.push_front(QueuedRequest(requestID, std::move(req)));

  c->issuePendingRequest();
}


bool VFS_Connections::Connection::requestIsPending(RequestID requestID) const
{
  if (m_currentRequestID == requestID) {
    return true;
  }

  for (QueuedRequest const &qr : m_queuedRequests) {
    if (qr.m_requestID == requestID) {
      return true;
    }
  }

  return false;
}


bool VFS_Connections::requestIsPending(RequestID requestID) const
{
  for (auto const &kv : m_connections) {
    Connection const *c = kv.second.get();
    if (c->requestIsPending(requestID)) {
      return true;
    }
  }

  return false;
}


bool VFS_Connections::replyIsAvailable(RequestID requestID) const
{
  return contains(m_availableReplies, requestID);
}


void VFS_Connections::Connection::issuePendingRequest()
{
  if (!m_queuedRequests.empty()) {
    if (m_fsQuery->isReady()) {
      xassert(m_currentRequestID == 0);

      QueuedRequest const &qr = m_queuedRequests.back();
      m_currentRequestID = qr.m_requestID;
      TRACE("VFS_Connections",
        "sending: requestID=" << m_currentRequestID <<
        " host=" << m_hostName <<
        " type=" << toString(qr.m_requestObject->messageType()));
      m_fsQuery->sendRequest(*(qr.m_requestObject));
      m_queuedRequests.pop_back();
    }
    else {
      TRACE("VFS_Connections",
        "issuePendingRequest(" << m_hostName << "): connection not ready");
    }
  }
  else {
    TRACE("VFS_Connections",
      "issuePendingRequest(" << m_hostName << "): no queued requests");
  }
}


std::unique_ptr<VFS_Message> VFS_Connections::takeReply(
  RequestID requestID)
{
  auto it = m_availableReplies.find(requestID);
  xassert(it != m_availableReplies.end());

  std::unique_ptr<VFS_Message> ret(std::move((*it).second));

  TRACE("VFS_Connections",
    "takeReply: requestID=" << requestID <<
    " type=" << toString(ret->messageType()));

  m_availableReplies.erase(it);

  return ret;
}


bool VFS_Connections::Connection::cancelRequest(RequestID requestID)
{
  if (m_currentRequestID == requestID) {
    // This will signal for 'on_replyAvailable' to discard it.
    m_currentRequestID = 0;
    return true;
  }

  // Remove a queued request.  This is checked last because it could be
  // slow.
  for (auto it = m_queuedRequests.begin();
       it != m_queuedRequests.end(); ++it) {
    if ((*it).m_requestID == requestID) {
      m_queuedRequests.erase(it);
      return true;
    }
  }

  return false;
}


void VFS_Connections::cancelRequest(RequestID requestID)
{
  TRACE("VFS_Connections", "cancelRequest(" << requestID << ")");

  // Remove a pending reply.
  auto it = m_availableReplies.find(requestID);
  if (it != m_availableReplies.end()) {
    m_availableReplies.erase(it);
    return;
  }

  // Check with the connections.
  for (auto const &kv : m_connections) {
    Connection *c = kv.second.get();
    if (c->cancelRequest(requestID)) {
      return;
    }
  }
}


void VFS_Connections::shutdown(HostName const &hostName)
{
  TRACE("VFS_Connections", "shutdown(" << hostName << ")");

  conn(hostName)->m_fsQuery->shutdown();

  m_connections.erase(hostName);
  vec_erase(m_validHostNames, hostName);
}


void VFS_Connections::shutdownAll()
{
  TRACE("VFS_Connections", "shutdownAll");

  // Make a copy of the names so I can safely iterate over it while
  // modifying the real data.
  std::vector<HostName> names(getHostNames());

  for (HostName const &hn : names) {
    shutdown(hn);
  }
}


bool VFS_Connections::connectionWasLost(HostName const &hostName) const
{
  return connC(hostName)->m_fsQuery->hasFailed();
}


VFS_Connections::Connection * NULLABLE
  VFS_Connections::signalRecipientConnection()
{
  // Get the object that sent the message.
  //
  // This is a bit of ugliness that would be fixed if I sent the signals
  // directly to the Connection object.
  QObject *src = this->QObject::sender();

  // Look for it among our connections.
  for (auto const &kv : m_connections) {
    Connection *c = kv.second.get();
    if (c->m_fsQuery.get() == src) {
      return c;
    }
  }

  return nullptr;
}


void VFS_Connections::on_connected() NOEXCEPT
{
  TRACE("VFS_Connections", "on_connected");

  GENERIC_CATCH_BEGIN

  if (Connection *c = signalRecipientConnection()) {
    c->issuePendingRequest();
    Q_EMIT signal_connected(c->m_hostName);
    return;
  }

  TRACE("VFS_Connections", "on_connected: did not find recipient");

  GENERIC_CATCH_END
}


void VFS_Connections::on_replyAvailable() NOEXCEPT
{
  TRACE("VFS_Connections", "on_replyAvailable");

  GENERIC_CATCH_BEGIN

  if (Connection *c = signalRecipientConnection()) {
    RequestID requestID = c->m_currentRequestID;

    if (requestID == 0) {
      // The request was cancelled while in flight.
      c->m_fsQuery->takeReply();
    }
    else {
      // Save the reply for the client who presents the right ID.
      insertMapUniqueMove(m_availableReplies,
        requestID, c->m_fsQuery->takeReply());

      // Clear the ID member so we know no request is outstanding.
      c->m_currentRequestID = 0;
    }

    // Notify clients.
    Q_EMIT signal_replyAvailable(requestID);

    // Send the next request, if there is one.
    c->issuePendingRequest();

    return;
  }

  TRACE("VFS_Connections", "on_replyAvailable: did not find recipient");

  GENERIC_CATCH_END
}


void VFS_Connections::on_failureAvailable() NOEXCEPT
{
  TRACE("VFS_Connections", "on_failureAvailable");

  GENERIC_CATCH_BEGIN

  if (Connection *c = signalRecipientConnection()) {
    string reason = c->m_fsQuery->getFailureReason();
    c->m_currentRequestID = 0;

    Q_EMIT signal_vfsConnectionLost(c->m_hostName, reason);
  }
  else {
    TRACE("VFS_Connections", "on_failureAvailable: did not find recipient");
  }

  GENERIC_CATCH_END
}


// EOF
