// vfs-connections.cc
// Code for vfs-connections.h.

#include "vfs-connections.h"           // this module

// editor
#include "vfs-query.h"                 // VFS_FileSystemQuery

// smbase
#include "smbase/container-util.h"     // smbase::contains
#include "smbase/exc.h"                // GENERIC_CATCH_BEGIN/END
#include "smbase/map-util.h"           // mapInsertUniqueMove, keySet
#include "smbase/ordered-map.h"        // smbase::OrderedMap
#include "smbase/sm-file-util.h"       // SMFileUtil
#include "smbase/trace.h"              // TRACE
#include "smbase/vector-util.h"        // vecEraseAll, vecToElementSet
#include "smbase/xassert.h"            // xfailure, xfailure_stringbc

// libc++
#include <set>                         // std::set
#include <utility>                     // std::move

using namespace smbase;


// ---------------------------- Connection -----------------------------
VFS_Connections::Connection::Connection(VFS_Connections *connections,
                                        HostName const &hostName)
  : m_connections(connections),
    m_hostName(hostName),
    m_fsQuery(new VFS_FileSystemQuery),
    m_haveStartingDirectory(false),
    m_startingDirectory(),
    m_currentRequestID(0),
    m_queuedRequests()
{
  xassertPrecondition(connections != nullptr);

  // The signals generated by 'm_fsQuery' are sent to 'm_connections'
  // for processing.
  //
  // It might be a good idea to change this to have the Connection
  // object handle the signals directly.
  QObject::connect(m_fsQuery.get(), &VFS_FileSystemQuery::signal_vfsConnected,
                   m_connections, &VFS_Connections::on_vfsConnected);
  QObject::connect(m_fsQuery.get(), &VFS_FileSystemQuery::signal_vfsReplyAvailable,
                   m_connections, &VFS_Connections::on_vfsReplyAvailable);
  QObject::connect(m_fsQuery.get(), &VFS_FileSystemQuery::signal_vfsFailureAvailable,
                   m_connections, &VFS_Connections::on_vfsFailureAvailable);

  m_fsQuery->connect(m_hostName);

  selfCheck();
}


VFS_Connections::Connection::~Connection()
{
  // See doc/signals-and-dtors.txt.
  QObject::disconnect(m_fsQuery.get(), nullptr, m_connections, nullptr);
}


void VFS_Connections::Connection::selfCheck() const
{
  xassert(m_connections != nullptr);
  xassert(m_fsQuery != nullptr);

  SMFileUtil sfu;
  xassert(sfu.hasNormalizedPathSeparators(m_startingDirectory));
}


// Note: Some Connection methods are defined further below, near the
// functions that call them.


// ------------------------- VFS_Connections ---------------------------
VFS_Connections::VFS_Connections()
  : QObject(),
    m_nextRequestID(1),
    m_connections(),
    m_availableReplies()
{}


VFS_Connections::~VFS_Connections()
{}


void VFS_Connections::selfCheck() const
{
  for (auto const &kv : m_connections) {
    HostName const &host = kv.first;
    Connection const *conn = kv.second.get();

    xassert(conn->m_hostName == host);
    conn->selfCheck();
  }
}


VFS_Connections::Connection const * NULLABLE VFS_Connections::ifConnC(
  HostName const &hostName) const
{
  if (m_connections.contains(hostName)) {
    return m_connections.valueAtKey(hostName).get();
  }
  else {
    return nullptr;
  }
}


VFS_Connections::Connection const *
  VFS_Connections::connC(HostName const &hostName) const
{
  if (Connection const *c = ifConnC(hostName)) {
    return c;
  }
  else {
    xfailure_stringbc("Invalid host: " << hostName);
    return nullptr;  // Not reached.
  }
}


VFS_Connections::ConnectionState VFS_Connections::connectionState(
  HostName const &hostName) const
{
  if (Connection const *c = ifConnC(hostName)) {
    return c->connectionState();
  }
  else {
    return CS_INVALID;
  }
}


VFS_Connections::ConnectionState
VFS_Connections::Connection::connectionState() const
{
  static_assert(VFS_FileSystemQuery::NUM_STATES == 7);

  switch (m_fsQuery->state()) {
    default:
      xfailure("invalid state");

    case VFS_FileSystemQuery::S_CREATED:
    case VFS_FileSystemQuery::S_CONNECTING:
      return CS_CONNECTING;

    case VFS_FileSystemQuery::S_READY:
    case VFS_FileSystemQuery::S_PENDING:
    case VFS_FileSystemQuery::S_HAS_REPLY:
      if (m_haveStartingDirectory) {
        return CS_READY;
      }
      else {
        return CS_CONNECTING;
      }

    case VFS_FileSystemQuery::S_FAILED:
    case VFS_FileSystemQuery::S_DEAD:
      if (m_haveStartingDirectory) {
        return CS_FAILED_AFTER_CONNECTING;
      }
      else {
        return CS_FAILED_BEFORE_CONNECTING;
      }
  }

  // Not reached.
}


std::vector<HostName> VFS_Connections::getHostNames() const
{
  std::vector<HostName> ret;
  for (auto const &kv : m_connections) {
    ret.push_back(kv.first);
  }
  return ret;
}


void VFS_Connections::connect(HostName const &hostName)
{
  TRACE("VFS_Connections", "connect: " << hostName);

  xassert(!isValid(hostName));

  // Add 'hostName' to our data structures, and create the Connection
  // object to hold its details.  The Connection constructor starts the
  // process of establishing a connection.
  m_connections.setValueAtNewKey(HostName(hostName),
    std::unique_ptr<Connection>(new Connection(this, hostName)));

  // Enqueue an initial request to get the starting directory.  Only
  // when that reply is received will we inform clients that the
  // connection is ready for use.
  Connection *c = conn(hostName);
  xassert(!c->m_haveStartingDirectory);
  std::unique_ptr<VFS_FileStatusRequest> req(new VFS_FileStatusRequest);
  req->m_path = ".";
  c->issueRequest(m_nextRequestID++, std::move(req));
}


bool VFS_Connections::isOrWasConnected(HostName const &hostName) const
{
  ConnectionState cs = connectionState(hostName);
  return cs == CS_READY ||
         cs == CS_FAILED_AFTER_CONNECTING;
}


string VFS_Connections::getStartingDirectory(HostName const &hostName) const
{
  xassert(isOrWasConnected(hostName));
  return connC(hostName)->m_startingDirectory;
}


void VFS_Connections::issueRequest(RequestID /*OUT*/ &requestID,
                                   HostName const &hostName,
                                   std::unique_ptr<VFS_Message> req)
{
  requestID = m_nextRequestID++;
  Connection *c = conn(hostName);

  c->issueRequest(requestID, std::move(req));
}


void VFS_Connections::Connection::issueRequest(
  RequestID requestID, std::unique_ptr<VFS_Message> req)
{
  TRACE("VFS_Connections",
    "enqueued: requestID=" << requestID <<
    " host=" << m_hostName <<
    " type=" << toString(req->messageType()));

  m_queuedRequests.push_front(QueuedRequest(requestID, std::move(req)));
  issuePendingRequest();
}


bool VFS_Connections::Connection::requestIsPending(RequestID requestID) const
{
  if (m_currentRequestID == requestID) {
    return true;
  }

  for (QueuedRequest const &qr : m_queuedRequests) {
    if (qr.m_requestID == requestID) {
      return true;
    }
  }

  return false;
}


bool VFS_Connections::requestIsPending(RequestID requestID) const
{
  for (auto const &kv : m_connections) {
    Connection const *c = kv.second.get();
    if (c->requestIsPending(requestID)) {
      return true;
    }
  }

  return false;
}


bool VFS_Connections::replyIsAvailable(RequestID requestID) const
{
  return contains(m_availableReplies, requestID);
}


void VFS_Connections::Connection::issuePendingRequest()
{
  if (!m_queuedRequests.empty()) {
    if (m_fsQuery->isReady()) {
      xassert(m_currentRequestID == 0);

      QueuedRequest const &qr = m_queuedRequests.back();
      m_currentRequestID = qr.m_requestID;
      TRACE("VFS_Connections",
        "sending: requestID=" << m_currentRequestID <<
        " host=" << m_hostName <<
        " " << qr.m_requestObject->description());
      m_fsQuery->sendRequest(*(qr.m_requestObject));
      m_queuedRequests.pop_back();
    }
    else {
      TRACE("VFS_Connections",
        "issuePendingRequest(" << m_hostName << "): connection not ready");
    }
  }
  else {
    TRACE("VFS_Connections",
      "issuePendingRequest(" << m_hostName << "): no queued requests");
  }
}


std::unique_ptr<VFS_Message> VFS_Connections::takeReply(
  RequestID requestID)
{
  auto it = m_availableReplies.find(requestID);
  xassert(it != m_availableReplies.end());

  std::unique_ptr<VFS_Message> ret(std::move((*it).second));

  TRACE("VFS_Connections",
    "takeReply: requestID=" << requestID <<
    " " << ret->description());

  m_availableReplies.erase(it);

  return ret;
}


bool VFS_Connections::Connection::cancelRequest(RequestID requestID)
{
  if (m_currentRequestID == requestID) {
    // This will signal for 'on_vfsReplyAvailable' to discard it.
    m_currentRequestID = 0;
    return true;
  }

  // Remove a queued request.  This is checked last because it could be
  // slow.
  for (auto it = m_queuedRequests.begin();
       it != m_queuedRequests.end(); ++it) {
    if ((*it).m_requestID == requestID) {
      m_queuedRequests.erase(it);
      return true;
    }
  }

  return false;
}


void VFS_Connections::cancelRequest(RequestID requestID)
{
  TRACE("VFS_Connections", "cancelRequest(" << requestID << ")");

  // Remove a pending reply.
  auto it = m_availableReplies.find(requestID);
  if (it != m_availableReplies.end()) {
    m_availableReplies.erase(it);
    return;
  }

  // Check with the connections.
  for (auto const &kv : m_connections) {
    Connection *c = kv.second.get();
    if (c->cancelRequest(requestID)) {
      return;
    }
  }
}


int VFS_Connections::numPendingRequests() const
{
  int ret = 0;
  for (auto const &kv : m_connections) {
    Connection const *c = kv.second.get();
    ret += c->numPendingRequests();
  }
  return ret;
}


int VFS_Connections::Connection::numPendingRequests() const
{
  int ret = 0;

  if (m_currentRequestID != 0) {
    ret++;
  }

  ret += (int)(m_queuedRequests.size());

  return ret;
}


int VFS_Connections::numAvailableReplies() const
{
  return (int)(m_availableReplies.size());
}


void VFS_Connections::shutdown(HostName const &hostName)
{
  TRACE("VFS_Connections", "shutdown(" << hostName << ")");

  conn(hostName)->m_fsQuery->shutdown();

  m_connections.eraseExistingKey(hostName);
}


void VFS_Connections::shutdownAll()
{
  TRACE("VFS_Connections", "shutdownAll");

  // Make a copy of the names so I can safely iterate over it while
  // modifying the real data.
  std::vector<HostName> names(getHostNames());

  for (HostName const &hn : names) {
    shutdown(hn);
  }
}


bool VFS_Connections::connectionFailed(HostName const &hostName) const
{
  ConnectionState cs = connectionState(hostName);
  return cs == CS_FAILED_BEFORE_CONNECTING ||
         cs == CS_FAILED_AFTER_CONNECTING;
}


VFS_Connections::Connection * NULLABLE
  VFS_Connections::signalRecipientConnection()
{
  // Get the object that sent the message.
  //
  // This is a bit of ugliness that would be fixed if I sent the signals
  // directly to the Connection object.
  QObject *src = this->QObject::sender();

  // Look for it among our connections.
  for (auto const &kv : m_connections) {
    Connection *c = kv.second.get();
    if (c->m_fsQuery.get() == src) {
      return c;
    }
  }

  return nullptr;
}


void VFS_Connections::on_vfsConnected() NOEXCEPT
{
  TRACE("VFS_Connections", "on_vfsConnected");

  GENERIC_CATCH_BEGIN

  if (Connection *c = signalRecipientConnection()) {
    // Trigger sending the first request, which should be the query for
    // the starting directory.
    c->issuePendingRequest();
    return;
  }

  TRACE("VFS_Connections", "on_vfsConnected: did not find recipient");

  GENERIC_CATCH_END
}


void VFS_Connections::on_vfsReplyAvailable() NOEXCEPT
{
  TRACE("VFS_Connections", "on_vfsReplyAvailable");

  GENERIC_CATCH_BEGIN

  if (Connection *c = signalRecipientConnection()) {
    RequestID requestID = c->m_currentRequestID;

    if (requestID == 0) {
      // The request was canceled while in flight.
      c->m_fsQuery->takeReply();
    }

    else if (!c->m_haveStartingDirectory) {
      // This is supposed to be the reply for the initial directory
      // request.
      xassert(c->connectionState() == CS_CONNECTING);
      std::unique_ptr<VFS_Message> genericReply(c->m_fsQuery->takeReply());
      TRACE("VFS_Connections",
        "  for host " << c->m_hostName <<
        ", got starting directory reply: " << genericReply->description());

      if (VFS_FileStatusReply const *reply =
            genericReply->asFileStatusReplyC()) {
        if (reply->m_success) {
          if (reply->m_dirExists) {
            SMFileUtil sfu;

            c->m_haveStartingDirectory = true;
            c->m_startingDirectory =
              sfu.normalizePathSeparators(reply->m_dirName);
            c->m_currentRequestID = 0;
            xassert(c->connectionState() == CS_READY);

            // Only now do we regard this as "connected" from the client
            // perspective.
            Q_EMIT signal_vfsConnected(c->m_hostName);
          }
          else {
            c->m_fsQuery->markAsFailed(
              "The initial directory query reply had m_dirExists=false.");
          }
        }
        else {
          c->m_fsQuery->markAsFailed(
            "The initial directory query reply had m_success=false.");
        }
      }
      else {
        c->m_fsQuery->markAsFailed(stringb(
          "The initial directory query reply had the wrong type: " <<
          genericReply->messageType()));
      }
    }

    else {
      // Save the reply for the client who presents the right ID.
      mapInsertUniqueMove(m_availableReplies,
        requestID, c->m_fsQuery->takeReply());

      // Clear the ID member so we know no request is outstanding.
      c->m_currentRequestID = 0;

      // Notify clients.
      Q_EMIT signal_vfsReplyAvailable(requestID);
    }

    // Send the next request, if there is one.
    c->issuePendingRequest();

    return;
  }

  TRACE("VFS_Connections", "on_vfsReplyAvailable: did not find recipient");

  GENERIC_CATCH_END
}


void VFS_Connections::on_vfsFailureAvailable() NOEXCEPT
{
  TRACE("VFS_Connections", "on_vfsFailureAvailable");

  GENERIC_CATCH_BEGIN

  if (Connection *c = signalRecipientConnection()) {
    string reason = c->m_fsQuery->getFailureReason();
    c->m_currentRequestID = 0;
    xassert(connectionFailed(c->m_hostName));

    Q_EMIT signal_vfsFailed(c->m_hostName, reason);
  }
  else {
    TRACE("VFS_Connections", "on_vfsFailureAvailable: did not find recipient");
  }

  GENERIC_CATCH_END
}


DEFINE_ENUMERATION_TO_STRING(
  VFS_Connections::ConnectionState,
  VFS_Connections::NUM_CONNECTION_STATES,
  (
    "CS_INVALID",
    "CS_CONNECTING",
    "CS_READY",
    "CS_FAILED_BEFORE_CONNECTING",
    "CS_FAILED_AFTER_CONNECTING",
  )
)


// EOF
